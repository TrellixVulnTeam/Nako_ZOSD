{"ast":null,"code":"import EventEmitter from \"events\";\nimport { delay } from \"../utils/utils\";\n\nconst tuple = (...args) => args;\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n  subscribe(method, type, callbackFn) {\n    this.lifetimeSubscriptionCount++;\n    let resolve;\n    const promise = new Promise(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n    const sub = {\n      method: method,\n      type: type,\n      fn: callbackFn !== null && callbackFn !== void 0 ? callbackFn : () => {\n        this.unsubscribe(id);\n      },\n      res: resolve,\n      id: id\n    };\n    this.subscriptions.push(sub);\n    return callbackFn ? id : promise;\n  }\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n\n\n  unsubscribe(id) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`);\n    }\n  }\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n\n\n  unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  close(removeAllListeners = true, code, reason) {\n    this.connection.close(code, reason);\n\n    if (removeAllListeners) {\n      this.emitter.removeAllListeners();\n    }\n  }\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n\n\n  async send(msg, timeout = -1) {\n    while (this.connection.readyState !== this.connection.OPEN) {\n      await delay(500);\n    }\n\n    this.connection.send(JSON.stringify(msg));\n    this.emitter.emit(\"messageSent\", msg);\n\n    if (msg.method === \"req\") {\n      let res;\n\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = await this.subscribe(\"res\", msg.type);\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL) {\n    this.connection = void 0;\n    this.subscriptions = new Array();\n    this.lifetimeSubscriptionCount = 0;\n    this.emitter = new EventEmitter();\n\n    this.on = (event, listener) => this.emitter.on(event, listener);\n\n    this.off = (event, listener) => this.emitter.off(event, listener);\n\n    window.Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg;\n          this.emitter.emit(\"messageReceived\", parsedMsg); // Resolve subscriptions\n\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.warn(\"Invalid message:\");\n          console.warn(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\");\n        console.error(error);\n        console.error(e.data);\n      }\n    };\n\n    this.connection.onclose = e => this.emitter.emit(\"close\", e);\n\n    this.connection.onerror = e => this.emitter.emit(\"error\", e);\n  }\n\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\nconst WebSocketMessageTypeArray = tuple(\"lobby_create\", \"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"game_end\", \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\n// export function parseMessage(msg: string) {\n//   const msgObject = JSON.parse(msg);\n//   // Should still return false when undefined\n//   if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n//     // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n//     const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n//     try {\n//       switch (parsedMsg.method) {\n//         case \"req\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid request type.`);\n//           }\n//         case \"res\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid response type.`);\n//           }\n//         case \"post\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_close\":\n//               return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid post type.`);\n//           }\n//         default:\n//           throw new Error(`${parsedMsg.method} is not a valid message method.`);\n//       }\n//     } catch (error) {\n//       console.log(error);\n//       console.log(parsedMsg);\n//     }\n//   } else {\n//     return undefined;\n//   }\n// }\nexport default NakoAPI;","map":{"version":3,"sources":["/Users/mac/Desktop/Nako/nako/src/modules/websocket-messages.ts"],"names":["EventEmitter","delay","tuple","args","NakoAPI","subscribe","method","type","callbackFn","lifetimeSubscriptionCount","resolve","promise","Promise","res","id","sub","fn","unsubscribe","subscriptions","push","idx","findIndex","i","splice","Error","unsubscribeAll","close","removeAllListeners","code","reason","connection","emitter","send","msg","timeout","readyState","OPEN","JSON","stringify","emit","race","then","undefined","constructor","socketURL","Array","on","event","listener","off","window","Nako","WebSocket","onmessage","e","parse","data","WebSocketMessageMethodArray","includes","WebSocketMessageTypeArray","parsedMsg","filter","j","payload","console","warn","error","log","onclose","onerror"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,QAAzB;AAEA,SAASC,KAAT,QAAsB,gBAAtB;;AAKA,MAAMC,KAAK,GAAG,CAAyB,GAAGC,IAA5B,KAAwCA,IAAtD;;AAeA;AACA;AACA;AACA,MAAMC,OAAN,CAAc;AAOZ;AACF;AACA;AACA;AACA;AACA;;AAGE;AACF;AACA;AACA;AACA;AACA;AACA;AAKE;AAEOC,EAAAA,SAAS,CACdC,MADc,EACHC,IADG,EACMC,UADN,EAEmC;AACjD,SAAKC,yBAAL;AACA,QAAIC,OAAJ;AACA,UAAMC,OAAO,GAAG,IAAIC,OAAJ,CAA2CC,GAAG,IAAIH,OAAO,GAAGG,GAA5D,CAAhB;AACA,UAAMC,EAAE,GAAG,KAAKL,yBAAhB;AAEA,UAAMM,GAAgC,GAAG;AACvCT,MAAAA,MAAM,EAAEA,MAD+B;AAEvCC,MAAAA,IAAI,EAAEA,IAFiC;AAGvCS,MAAAA,EAAE,EAAER,UAAF,aAAEA,UAAF,cAAEA,UAAF,GAAiB,MAAM;AAAC,aAAKS,WAAL,CAAiBH,EAAjB;AAAsB,OAHT;AAIvCD,MAAAA,GAAG,EAAEH,OAJkC;AAKvCI,MAAAA,EAAE,EAAEA;AALmC,KAAzC;AAQA,SAAKI,aAAL,CAAmBC,IAAnB,CAAwBJ,GAAxB;AAEA,WAAOP,UAAU,GAAGM,EAAH,GAAQH,OAAzB;AACD;AAED;AACF;AACA;AACA;;;AACSM,EAAAA,WAAW,CAACH,EAAD,EAAa;AAC7B,UAAMM,GAAG,GAAG,KAAKF,aAAL,CAAmBG,SAAnB,CAA6BC,CAAC,IAAIA,CAAC,CAACR,EAAF,KAASA,EAA3C,CAAZ;;AAEA,QAAIM,GAAG,KAAK,CAAC,CAAb,EAAgB;AACd,WAAKF,aAAL,CAAmBK,MAAnB,CAA0BH,GAA1B,EAA+B,CAA/B;AACD,KAFD,MAEO;AACL,YAAM,IAAII,KAAJ,CAAW,wBAAuBV,EAAG,aAArC,CAAN;AACD;AACF;AAED;AACF;AACA;;;AACSW,EAAAA,cAAc,GAAG;AACtB,SAAKP,aAAL,GAAqB,EAArB;AACD;;AASMQ,EAAAA,KAAK,CAACC,kBAAkB,GAAG,IAAtB,EAA4BC,IAA5B,EAA2CC,MAA3C,EAA4D;AACtE,SAAKC,UAAL,CAAgBJ,KAAhB,CAAsBE,IAAtB,EAA4BC,MAA5B;;AAEA,QAAIF,kBAAJ,EAAwB;AACtB,WAAKI,OAAL,CAAaJ,kBAAb;AACD;AACF;AAED;AACF;AACA;AACA;;;AAoBmB,QAAJK,IAAI,CAAmEC,GAAnE,EAAgGC,OAAO,GAAG,CAAC,CAA3G,EAA6K;AAC5L,WAAO,KAAKJ,UAAL,CAAgBK,UAAhB,KAA+B,KAAKL,UAAL,CAAgBM,IAAtD,EAA4D;AAC1D,YAAMnC,KAAK,CAAC,GAAD,CAAX;AACD;;AAED,SAAK6B,UAAL,CAAgBE,IAAhB,CAAqBK,IAAI,CAACC,SAAL,CAAeL,GAAf,CAArB;AACA,SAAKF,OAAL,CAAaQ,IAAb,CAAkB,aAAlB,EAAiCN,GAAjC;;AAEA,QAAIA,GAAG,CAAC3B,MAAJ,KAAe,KAAnB,EAA0B;AACxB,UAAIO,GAAJ;;AACA,UAAIqB,OAAO,IAAI,CAAf,EAAkB;AAChBrB,QAAAA,GAAG,GAAG,MAAMD,OAAO,CAAC4B,IAAR,CAAa,CAAC,KAAKnC,SAAL,CAAe,KAAf,EAAsB4B,GAAG,CAAC1B,IAA1B,CAAD,EAAkCN,KAAK,CAACiC,OAAD,CAAL,CAAeO,IAAf,CAAoB,MAAMC,SAA1B,CAAlC,CAAb,CAAZ;AACD,OAFD,MAEO;AACL7B,QAAAA,GAAG,GAAI,MAAM,KAAKR,SAAL,CAAe,KAAf,EAAsB4B,GAAG,CAAC1B,IAA1B,CAAb;AACD;;AAED,aAAOM,GAAP;AACD;AACF;;AAED8B,EAAAA,WAAW,CAACC,SAAD,EAAoB;AAAA,SA/HvBd,UA+HuB;AAAA,SA7HvBZ,aA6HuB,GA7HP,IAAI2B,KAAJ,EA6HO;AAAA,SA3HvBpC,yBA2HuB,GA3HK,CA2HL;AAAA,SA1DvBsB,OA0DuB,GA1Db,IAAI/B,YAAJ,EA0Da;;AAAA,SAvDxB8C,EAuDwB,GAvDnB,CAA+BC,KAA/B,EAAyCC,QAAzC,KAAuE,KAAKjB,OAAL,CAAae,EAAb,CAAgBC,KAAhB,EAAuBC,QAAvB,CAuDpD;;AAAA,SArDxBC,GAqDwB,GArDlB,CAA+BF,KAA/B,EAAyCC,QAAzC,KAAuE,KAAKjB,OAAL,CAAakB,GAAb,CAAiBF,KAAjB,EAAwBC,QAAxB,CAqDrD;;AAC5BE,IAAAA,MAAD,CAAgBC,IAAhB,GAAuB,IAAvB;AACA,SAAKrB,UAAL,GAAkB,IAAIsB,SAAJ,CAAcR,SAAd,CAAlB;;AAEA,SAAKd,UAAL,CAAgBuB,SAAhB,GAA4BC,CAAC,IAAI;AAC/B,UAAI;AACF,cAAMrB,GAAG,GAAGI,IAAI,CAACkB,KAAL,CAAWD,CAAC,CAACE,IAAb,CAAZ;;AAEA,YAAIC,2BAA2B,CAACC,QAA5B,CAAqCzB,GAAG,CAAC3B,MAAzC,KAAoDqD,yBAAyB,CAACD,QAA1B,CAAmCzB,GAAG,CAAC1B,IAAvC,CAAxD,EAAsG;AACpG,gBAAMqD,SAAS,GAAG3B,GAAlB;AACA,eAAKF,OAAL,CAAaQ,IAAb,CAAkB,iBAAlB,EAAqCqB,SAArC,EAFoG,CAIpG;;AACA,eAAK,MAAMtC,CAAX,IAAgB,KAAKJ,aAAL,CAAmB2C,MAAnB,CAA0BC,CAAC,IAAIA,CAAC,CAACxD,MAAF,KAAasD,SAAS,CAACtD,MAAvB,IAAiCwD,CAAC,CAACvD,IAAF,KAAWqD,SAAS,CAACrD,IAArF,CAAhB,EAA4G;AAC1Ge,YAAAA,CAAC,CAACT,GAAF,CAAM+C,SAAS,CAACG,OAAhB;AACAzC,YAAAA,CAAC,CAACN,EAAF,CAAK4C,SAAS,CAACG,OAAf,EAAwBzC,CAAC,CAACR,EAA1B;AACD;AACF,SATD,MASO;AACLkD,UAAAA,OAAO,CAACC,IAAR,CAAa,kBAAb;AACAD,UAAAA,OAAO,CAACC,IAAR,CAAahC,GAAb;AACD;AACF,OAhBD,CAgBE,OAAOiC,KAAP,EAAc;AACdF,QAAAA,OAAO,CAACG,GAAR,CAAY,iDAAZ;AACAH,QAAAA,OAAO,CAACE,KAAR,CAAcA,KAAd;AACAF,QAAAA,OAAO,CAACE,KAAR,CAAcZ,CAAC,CAACE,IAAhB;AACD;AACF,KAtBD;;AAwBA,SAAK1B,UAAL,CAAgBsC,OAAhB,GAA0Bd,CAAC,IAAI,KAAKvB,OAAL,CAAaQ,IAAb,CAAkB,OAAlB,EAA2Be,CAA3B,CAA/B;;AACA,SAAKxB,UAAL,CAAgBuC,OAAhB,GAA0Bf,CAAC,IAAI,KAAKvB,OAAL,CAAaQ,IAAb,CAAkB,OAAlB,EAA2Be,CAA3B,CAA/B;AACD;;AA9JW;;AAwMd,MAAMG,2BAA2B,GAAGvD,KAAK,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,CAAzC;AAIA,MAAMyD,yBAAyB,GAAGzD,KAAK,CAAC,cAAD,EAAiB,YAAjB,EAA+B,aAA/B,EAA8C,cAA9C,EAA8D,YAA9D,EAA4E,YAA5E,EAA0F,aAA1F,EAAyG,UAAzG,EACC,gBADD,EACmB,cADnB,EACmC,iBADnC,EACsD,aADtD,CAAvC;AAwJA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,eAAeE,OAAf","sourcesContent":["import EventEmitter from \"events\";\nimport TypedEmitter from \"typed-emitter\";\nimport { delay } from \"../utils/utils\";\nimport { AccountInfo } from \"./account-info\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype Narrowable = string | number | boolean | symbol | object | {} | void | null | undefined;\nconst tuple = <T extends Narrowable[]>(...args: T) => args;\n\ninterface WebSocketSubscription<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  fn: (res: WebSocketMessagePayload<M, T>, id: number) => void;\n  res: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n  id: number;\n}\n\ntype NakoAPIEvent = {\n  messageSent: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void,\n  messageReceived: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void,\n  close: (e: CloseEvent) => void,\n  error: (e: Event) => void;\n};\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  private connection: WebSocket;\n\n  private subscriptions = new Array<WebSocketSubscription<WebSocketMessageMethod, WebSocketMessageType>>();\n\n  private lifetimeSubscriptionCount = 0;\n\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(method: M, type: T): Promise<WebSocketMessagePayload<M, T>>;\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn: (message: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number;\n\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn?: (payload: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number | Promise<WebSocketMessagePayload<M, T>> {\n    this.lifetimeSubscriptionCount++;\n    let resolve: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n    const promise = new Promise<WebSocketMessagePayload<M, T>>(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n\n    const sub: WebSocketSubscription<M, T> = {\n      method: method,\n      type: type,\n      fn: callbackFn ?? (() => {this.unsubscribe(id);}),\n      res: resolve!,\n      id: id\n    };\n    \n    this.subscriptions.push(sub);\n\n    return callbackFn ? id : promise;\n  }\n\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n  public unsubscribe(id: number) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`);\n    }\n  }\n\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n  public unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  private emitter = new EventEmitter() as TypedEmitter<NakoAPIEvent>;\n\n  // You can't do public on = this.emitter.on; :[\n  public on = <E extends keyof NakoAPIEvent>(event: E, listener: NakoAPIEvent[E]) => this.emitter.on(event, listener);\n\n  public off = <E extends keyof NakoAPIEvent>(event: E, listener: NakoAPIEvent[E]) => this.emitter.off(event, listener);\n\n  public close(removeAllListeners = true, code?: number, reason?: string) {\n    this.connection.close(code, reason);\n\n    if (removeAllListeners) {\n      this.emitter.removeAllListeners();\n    }\n  }\n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n  public async send<M extends Exclude<WebSocketMessageMethod, \"req\">, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>): Promise<void>;\n  \n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @returns        A promise that is resolved toa WebSocketMessagePayload when a response is received.\n   */\n  public async send<M extends \"req\", T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>): Promise<WebSocketMessagePayload<\"res\", T>>;\n\n    /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @param  timeout This is the duration in ms that this function will wait for a response. Default is -1.\n   *                 Any value below 0 represents no timeout limit. No effects on response messages.\n   * @returns        A promise that is resolved to either a WebSocketMessagePayload when a response is received, or undefined if no response is received before timeout.\n   */\n     public async send<M extends \"req\", T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout?: number): Promise<undefined | WebSocketMessagePayload<\"res\", T>>;\n\n  public async send<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout = -1): Promise<void | undefined | WebSocketMessagePayload<\"res\", T>> {\n    while (this.connection.readyState !== this.connection.OPEN) {\n      await delay(500);\n    }\n\n    this.connection.send(JSON.stringify(msg));\n    this.emitter.emit(\"messageSent\", msg);\n\n    if (msg.method === \"req\") {\n      let res: undefined | WebSocketMessagePayload<\"res\", T>;\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = (await this.subscribe(\"res\", msg.type)) as WebSocketMessagePayload<\"res\", T>;\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL: string) {\n    (window as any).Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n          this.emitter.emit(\"messageReceived\", parsedMsg);\n          \n          // Resolve subscriptions\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.warn(\"Invalid message:\");\n          console.warn(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\");\n        console.error(error);\n        console.error(e.data);\n      }\n    };\n\n    this.connection.onclose = e => this.emitter.emit(\"close\", e);\n    this.connection.onerror = e => this.emitter.emit(\"error\", e);\n  }\n}\n\nexport type AccountRole = \"student\" | \"teacher\";\n\nexport type LobbyInfo = {\n  id: number;\n  players: string[];    // Should include self\n}\n\ntype BaseQuestionInfo<T> = {\n  question: string;\n  timeLimit: number;\n  answer: T;\n}\n\ntype SelectableChoices = {\n  choices: string[];\n  maxSelection: number;\n}\n\n// T is the type of answer\nexport type MultipleChoiceQuestion<T extends number | number[] = number> = BaseQuestionInfo<T> &\n  (T extends number ? Omit<SelectableChoices, \"maxSelection\"> : SelectableChoices);    // Imply 1 when omitted\n\ntype BaseFillBlankQuestion<T extends [string, string] | string[]> = {\n  context: T;\n}\n\nexport type FillBlankQuestion<T extends string | string[] | number | number[]> = BaseQuestionInfo<T> &\n  (T extends string | number ? BaseFillBlankQuestion<[string, string]> : BaseFillBlankQuestion<string[]> ) &\n  (T extends number | number[] ? Omit<SelectableChoices, \"maxSelection\"> : void);    // Can omit due to limited amount of blanks\n\nexport type QuestionFormat = MultipleChoiceQuestion<number | number[]> | FillBlankQuestion<string | string[] | number | number[]>;\n\nexport type QuestionInfo<R extends AccountRole, T extends QuestionFormat> = R extends \"teacher\" ? T : Omit<T, \"answer\">;\n\nexport type GameInfo<R extends AccountRole> = {\n  role: R;\n  questions: QuestionInfo<R, QuestionFormat>[];\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\n\nexport type WebSocketMessageMethod = (typeof WebSocketMessageMethodArray)[number];\n\nconst WebSocketMessageTypeArray = tuple(\"lobby_create\", \"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"game_end\",\n                                        \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\n\nexport type WebSocketMessageType = (typeof WebSocketMessageTypeArray)[number];\n\nexport type WebSocketMessagePayload<M extends WebSocketMessageMethod, T extends WebSocketMessageType> =\n  M extends \"req\" ?\n    T extends \"lobby_create\" ? LobbyCreateRequest :\n    T extends \"lobby_join\" ? LobbyJoinRequest :\n    T extends \"lobby_leave\" ? LobbyLeaveRequest :\n    T extends \"lobby_update\" ? LobbyUpdateRequest :\n    T extends \"keep_alive\" ? KeepAliveRequest :\n    T extends \"game_start\" ? GameStartRequest :\n    T extends \"game_update\" ? GameUpdateRequest :\n    T extends \"game_end\" ? GameEndRequest :\n    T extends \"question_start\" ? QuestionStartRequest :\n    T extends \"question_end\" ? QuestionEndRequest :\n    T extends \"answer_question\" ? AnswerQuestionRequest :\n    T extends \"lobby_close\" ? never :\n    WebSocketRequest :\n  M extends \"res\" ?\n    T extends \"lobby_create\" ? LobbyCreateResponse :\n    T extends \"lobby_join\" ? LobbyJoinResponse :\n    T extends \"lobby_leave\" ? LobbyLeaveResponse :\n    T extends \"lobby_update\" ? LobbyUpdateResponse :\n    T extends \"keep_alive\" ? KeepAliveResponse :\n    T extends \"game_start\" ? GameStartResponse :\n    T extends \"game_update\" ? GameUpdateResponse :\n    T extends \"game_end\" ? GameEndResponse :\n    T extends \"question_start\" ? QuestionStartResponse :\n    T extends \"question_end\" ? QuestionEndResponse :\n    T extends \"answer_question\" ? AnswerQuestionResponse :\n    T extends \"lobby_close\" ? never :\n    WebSocketResponse :\n  M extends \"post\" ?\n    T extends \"lobby_close\" ? LobbyCloseEvent :\n    T extends \"lobby_join\" ? never :\n    T extends \"lobby_leave\" ? never :\n    T extends \"lobby_update\" ? never :\n    T extends \"keep_alive\" ? never :\n    T extends \"game_start\" ? never :\n    T extends \"game_update\" ? never :\n    T extends \"game_end\" ? never :\n    T extends \"question_start\" ? never :\n    T extends \"question_end\" ? never :\n    T extends \"answer_question\" ? never :\n    WebSocketPost :\n  WebSocketRequest | WebSocketResponse\n\nexport interface WebSocketMessageMetadata<M extends WebSocketMessageMethod, T extends WebSocketMessageType> {\n  method: M;\n  type: T;\n}\n\nexport interface WebSocketMessage<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  payload: WebSocketMessagePayload<M, T>;\n}\n\nexport type WebSocketRequest = LobbyCreateRequest | LobbyJoinRequest | LobbyLeaveRequest | LobbyUpdateRequest | GameStartRequest | GameUpdateRequest |\n                               GameEndRequest | QuestionStartRequest | QuestionEndRequest | AnswerQuestionRequest | KeepAliveRequest;\n\nexport type WebSocketResponse = LobbyCreateResponse | LobbyJoinResponse | LobbyLeaveResponse | LobbyUpdateResponse | GameStartResponse | GameUpdateResponse |\n                                GameEndResponse | QuestionStartResponse | QuestionEndResponse | AnswerQuestionResponse | KeepAliveResponse;\n\nexport type WebSocketPost = LobbyCloseEvent;\n\nexport type LobbyCreateRequest = null;\n\nexport type LobbyCreateResponse = {\n  lobbyID: number;\n}\n\nexport type LobbyUpdateRequest = {    // Used only to check if the lobby exists\n  lobbyID: number;\n};\n\nexport type LobbyUpdateResponse = {\n  lobbyInfo: LobbyInfo;\n};\n\nexport type LobbyJoinRequest = {\n  lobbyID: number;\n  accountInfo: AccountInfo;\n};\n\nexport type LobbyJoinResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type LobbyLeaveRequest = {\n  lobbyID: number;\n  name: string;\n};\n\nexport type LobbyLeaveResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type KeepAliveRequest = null;\n\nexport type KeepAliveResponse = {\n  name: string;\n  lobbyID: number;\n};\n\nexport type GameStartRequest = {\n  gameInfo: GameInfo<AccountRole>;\n};\n\nexport type GameStartResponse = null;\n\nexport type GameUpdateRequest = {\n  currentQuestion: number;\n};\n\nexport type GameUpdateResponse = null;\n\nexport type GameEndRequest = {\n  name: string;\n  score: number;\n}[]\n\nexport type GameEndResponse = null;\n\nexport type QuestionStartRequest = null;\n\nexport type QuestionStartResponse = null;\n\nexport type QuestionEndRequest = {\n  correctAnswer: number;\n  stats: {\n    correct: number;\n    incorrect: number;\n    noAnswer: number;\n  }\n};\n\nexport type QuestionEndResponse = null;\n\nexport type AnswerQuestionRequest = {\n  choice: number;\n  currentQuestionCheck: number;\n};\n\nexport type AnswerQuestionResponse = null;\n\nexport type LobbyCloseEvent = {\n  reason?: string;\n};\n\n// export function parseMessage(msg: string) {\n//   const msgObject = JSON.parse(msg);\n//   // Should still return false when undefined\n//   if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n//     // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n//     const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n\n//     try {\n//       switch (parsedMsg.method) {\n//         case \"req\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n              \n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n                \n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n  \n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid request type.`);\n//           }\n  \n//         case \"res\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n  \n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n  \n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n  \n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid response type.`);\n//           }\n        \n//         case \"post\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_close\":\n//               return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid post type.`);\n//           }\n\n//         default:\n//           throw new Error(`${parsedMsg.method} is not a valid message method.`);\n//       }\n//     } catch (error) {\n//       console.log(error);\n//       console.log(parsedMsg);\n//     }\n//   } else {\n//     return undefined;\n//   }\n// }\n\nexport default NakoAPI;"]},"metadata":{},"sourceType":"module"}