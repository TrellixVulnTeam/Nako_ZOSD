{"ast":null,"code":"import { delay } from \"../utils\";\n\nconst tuple = (...args) => args;\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n\n  /**\n   * A function that triggers the callback function when a message of matching method and type is received.\n   * If only the first matching message is needed, utilize the promise returned by the function instead.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   *                   If it is not provided, the subscription will be cancelled after the first message.\n   * @returns          The ID of the subscription, or a Promise that resolves to the first matching message if callbackFn is not provided.\n   */\n  subscribe(method, type, callbackFn) {\n    this.lifetimeSubscriptionCount++;\n    let resolve;\n    const promise = new Promise(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n    const sub = {\n      method: method,\n      type: type,\n      fn: callbackFn !== null && callbackFn !== void 0 ? callbackFn : () => {\n        this.unsubscribe(id);\n      },\n      res: resolve,\n      id: id\n    };\n    this.subscriptions.push(sub);\n    return callbackFn ? promise : id;\n  }\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n\n\n  unsubscribe(id) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`);\n    }\n  }\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n\n\n  unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  close(code, reason) {\n    this.connection.close(code, reason);\n  }\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @param  timeout If the message is a request, this is the duration in ms that this function will wait for a response. Default is -1.\n   *                 Any value below 0 represents no timeout limit. No effects on response messages.\n   * @returns        A promise that is resolved to a WebSocketMessagePayload when a response is received, if the message is a request.\n   *                 Returns a Promise<void> if the response timed out or the sent message is not a request.\n   */\n\n\n  async send(msg, timeout = -1) {\n    if (msg.method === \"req\") {\n      if (timeout >= 0) {\n        const t = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout)]);\n\n        if (typeof t !== \"number\") {\n          return t;\n        }\n      } else {\n        const t = await this.subscribe(\"res\", msg.type);\n        return t;\n      }\n    }\n\n    this.connection.send(JSON.stringify(msg));\n  }\n\n  constructor(socketURL, websocketEvents) {\n    this.connection = void 0;\n    this.subscriptions = new Array();\n    this.lifetimeSubscriptionCount = 0;\n    this.onMessage = void 0;\n    this.onError = void 0;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg; // Resolve onMessage\n\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ? this.onMessage.forEach(i => i(parsedMsg)) : this.onMessage(parsedMsg);\n          } // Resolve subscriptions\n\n\n          for (const i of this.subscriptions) {\n            if (parsedMsg.method === i.method && parsedMsg.type === i.type) {\n              i.res(parsedMsg);\n              i.fn(parsedMsg, i.id);\n            }\n          }\n        } else {\n          console.log(\"Invalid message:\");\n          console.log(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\");\n        console.log(error);\n        console.log(e.data);\n      }\n    };\n\n    this.connection.onerror = e => {\n      var _this$onError;\n\n      return (_this$onError = this.onError) === null || _this$onError === void 0 ? void 0 : _this$onError.call(this, e);\n    };\n\n    this.onMessage = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onMessage;\n    this.onError = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onError;\n  }\n\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"answer_question\", \"lobby_close\");\nexport function parseMessage(msg) {\n  const msgObject = JSON.parse(msg); // Should still return false when undefined\n\n  if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n    // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n    const parsedMsg = msgObject;\n\n    try {\n      switch (parsedMsg.method) {\n        case \"req\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg;\n\n            case \"lobby_leave\":\n              return parsedMsg;\n\n            case \"lobby_update\":\n              return parsedMsg;\n\n            case \"keep_alive\":\n              return parsedMsg;\n\n            case \"game_start\":\n              return parsedMsg;\n\n            case \"game_update\":\n              return parsedMsg;\n\n            case \"answer_question\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid request type.`);\n          }\n\n        case \"res\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg;\n\n            case \"lobby_leave\":\n              return parsedMsg;\n\n            case \"lobby_update\":\n              return parsedMsg;\n\n            case \"keep_alive\":\n              return parsedMsg;\n\n            case \"game_start\":\n              return parsedMsg;\n\n            case \"game_update\":\n              return parsedMsg;\n\n            case \"answer_question\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid response type.`);\n          }\n\n        case \"post\":\n          switch (parsedMsg.type) {\n            case \"lobby_close\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid post type.`);\n          }\n\n        default:\n          throw new Error(`${parsedMsg.method} is not a valid message method.`);\n      }\n    } catch (error) {\n      console.log(error);\n      console.log(parsedMsg);\n    }\n  } else {\n    return undefined;\n  }\n}\nexport default NakoAPI;","map":{"version":3,"sources":["/Users/mac/Desktop/Nako/nako/src/modules/websocket-messages.ts"],"names":["delay","tuple","args","NakoAPI","subscribe","method","type","callbackFn","lifetimeSubscriptionCount","resolve","promise","Promise","res","id","sub","fn","unsubscribe","subscriptions","push","idx","findIndex","i","splice","Error","unsubscribeAll","close","code","reason","connection","send","msg","timeout","t","race","JSON","stringify","constructor","socketURL","websocketEvents","Array","onMessage","onError","WebSocket","onmessage","e","parse","data","WebSocketMessageMethodArray","includes","WebSocketMessageTypeArray","parsedMsg","isArray","forEach","console","log","error","onerror","parseMessage","msgObject","undefined"],"mappings":"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","sourcesContent":["import { delay } from \"../utils\";\n\ntype Narrowable = string | number | boolean | symbol | object | {} | void | null | undefined;\nconst tuple = <T extends Narrowable[]>(...args: T) => args;\n\ninterface WebSocketSubscription<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  fn: (res: WebSocketMessagePayload<M, T>, id: number) => void;\n  res: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n  id: number;\n}\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  private connection: WebSocket;\n\n  private subscriptions = new Array<WebSocketSubscription<WebSocketMessageMethod, WebSocketMessageType>>();\n\n  private lifetimeSubscriptionCount = 0;\n\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n\n  /**\n   * A function that triggers the callback function when a message of matching method and type is received.\n   * If only the first matching message is needed, utilize the promise returned by the function instead.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   *                   If it is not provided, the subscription will be cancelled after the first message.\n   * @returns          The ID of the subscription, or a Promise that resolves to the first matching message if callbackFn is not provided.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, \n    callbackFn?: (payload: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number | Promise<WebSocketMessagePayload<M, T>> {\n    this.lifetimeSubscriptionCount++;\n    let resolve: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n    const promise = new Promise<WebSocketMessagePayload<M, T>>(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n\n    const sub: WebSocketSubscription<M, T> = {\n      method: method,\n      type: type,\n      fn: callbackFn ?? (() => {this.unsubscribe(id)}),\n      res: resolve!,\n      id: id\n    }\n    \n    this.subscriptions.push(sub)\n\n    return callbackFn ? promise : id;\n  }\n\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n  public unsubscribe(id: number) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`)\n    }\n  }\n\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n  public unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  public onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void | ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[];\n\n  public onError?: (e: Event) => void;\n\n  public close(code?: number, reason?: string) {\n    this.connection.close(code, reason);\n  }\n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @param  timeout If the message is a request, this is the duration in ms that this function will wait for a response. Default is -1.\n   *                 Any value below 0 represents no timeout limit. No effects on response messages.\n   * @returns        A promise that is resolved to a WebSocketMessagePayload when a response is received, if the message is a request.\n   *                 Returns a Promise<void> if the response timed out or the sent message is not a request.\n   */\n  public async send<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout = -1): Promise<void | WebSocketMessagePayload<\"res\", T>> {\n    if (msg.method === \"req\") {\n      if (timeout >= 0) {\n        const t = await Promise.race([this.subscribe<\"res\", T>(\"res\", msg.type), delay(timeout)]);\n        if (typeof(t) !== \"number\") {\n          return t;\n        }\n      } else {\n        const t = (await this.subscribe<\"res\", T>(\"res\", msg.type)) as WebSocketMessagePayload<\"res\", T>;\n        return t;\n      }\n    }\n    \n    this.connection.send(JSON.stringify(msg));\n  }\n\n  constructor(socketURL: string, websocketEvents?: {\n    onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void,\n    onError?: (e: Event) => void\n  }) {\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n          \n          // Resolve onMessage\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ?\n            (this.onMessage as ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[]).forEach(i => i(parsedMsg)) :\n            this.onMessage(parsedMsg);\n          }\n          \n          // Resolve subscriptions\n          for (const i of this.subscriptions) {\n            if (parsedMsg.method === i.method && parsedMsg.type === i.type) {\n              i.res(parsedMsg);\n              i.fn(parsedMsg, i.id);\n            }\n          }\n        } else {\n          console.log(\"Invalid message:\");\n          console.log(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\")\n        console.log(error);\n        console.log(e.data);\n      }\n    }\n\n    this.connection.onerror = e => this.onError?.(e);\n\n    this.onMessage = websocketEvents?.onMessage;\n    this.onError = websocketEvents?.onError;\n  }\n}\n\nexport interface LobbyInfo {\n  id: number;\n  players: string[];    // Should include self\n}\n\nexport interface QuestionInfo {\n  question: string;\n  choices: string[];\n  timeLimit: number;\n}\n\nexport interface GameInfo {\n  questions: QuestionInfo[]\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\n\nexport type WebSocketMessageMethod = (typeof WebSocketMessageMethodArray)[number];\n\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"answer_question\", \"lobby_close\");\n\nexport type WebSocketMessageType = (typeof WebSocketMessageTypeArray)[number];\n\nexport type WebSocketMessagePayload<M extends WebSocketMessageMethod, T extends WebSocketMessageType> =\n  M extends \"req\" ? \n    T extends \"lobby_join\" ? LobbyJoinRequest :\n    T extends \"lobby_leave\" ? LobbyLeaveRequest :\n    T extends \"lobby_update\" ? LobbyUpdateRequest :\n    T extends \"keep_alive\" ? KeepAliveRequest :\n    T extends \"game_start\" ? GameStartRequest :\n    T extends \"game_update\" ? GameUpdateRequest :\n    T extends \"answer_question\" ? AnswerQuestionRequest :\n    T extends \"lobby_close\" ? never :\n    WebSocketRequest :\n  M extends \"res\" ?\n    T extends \"lobby_join\" ? LobbyJoinResponse :\n    T extends \"lobby_leave\" ? LobbyLeaveResponse :\n    T extends \"lobby_update\" ? LobbyUpdateResponse :\n    T extends \"keep_alive\" ? KeepAliveResponse :\n    T extends \"game_start\" ? GameStartResponse :\n    T extends \"game_update\" ? GameUpdateResponse :\n    T extends \"answer_question\" ? AnswerQuestionResponse :\n    T extends \"lobby_close\" ? never :\n    WebSocketResponse :\n  M extends \"post\" ?\n    T extends \"lobby_close\" ? LobbyCloseEvent :\n    T extends \"lobby_join\" ? never :\n    T extends \"lobby_leave\" ? never :\n    T extends \"lobby_update\" ? never :\n    T extends \"keep_alive\" ? never :\n    T extends \"game_start\" ? never :\n    T extends \"game_update\" ? never :\n    T extends \"answer_question\" ? never :\n    WebSocketPost :\n  WebSocketRequest | WebSocketResponse\n\nexport interface WebSocketMessageMetadata<M extends WebSocketMessageMethod, T extends WebSocketMessageType> {\n  method: M;\n  type: T;\n}\n\nexport interface WebSocketMessage<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  payload: WebSocketMessagePayload<M, T>;\n}\n\nexport type WebSocketRequest = LobbyJoinRequest | LobbyLeaveRequest | LobbyUpdateRequest | KeepAliveRequest;\n\nexport type WebSocketResponse = LobbyJoinResponse | LobbyLeaveResponse | LobbyUpdateResponse | KeepAliveResponse;\n\nexport type WebSocketPost = LobbyCloseEvent;\n\nexport type LobbyUpdateRequest = {    // Used only to check if the lobby exists\n  lobbyID: number;\n}\n\nexport type LobbyUpdateResponse = {\n  lobbyInfo: LobbyInfo | null;\n}\n\nexport type LobbyJoinRequest = {\n  lobbyID: number;\n  name: string;\n}\n\nexport type LobbyJoinResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n}\n\nexport type LobbyLeaveRequest = {\n  lobbyID: number;\n  name: string;\n}\n\nexport type LobbyLeaveResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n}\n\nexport type KeepAliveRequest = null;\n\nexport type KeepAliveResponse = {\n  name: string;\n  lobbyID: number;\n}\n\nexport type GameStartRequest = {\n  gameInfo: GameInfo;\n}\n\nexport type GameStartResponse = {\n}\n\nexport type GameUpdateRequest = {\n  currentQuestion: number;\n}\n\nexport type GameUpdateResponse = null;\n\nexport type QuestionStartRequest = null;\n\nexport type QuestionStartResponse = null;\n\nexport type QuestionEndRequest = null;\n\nexport type QuestionEndResponse = null;\n\nexport type AnswerQuestionRequest = {\n  choice: number;\n}\n\nexport type AnswerQuestionResponse = {\n  correctAnswer: number;\n}\n\nexport type LobbyCloseEvent = {\n  reason?: string;\n}\n\nexport function parseMessage(msg: string) {\n  const msgObject = JSON.parse(msg);\n  // Should still return false when undefined\n  if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n    // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n    const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n\n    try {\n      switch (parsedMsg.method) {\n        case \"req\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n              \n            case \"lobby_leave\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n                \n            case \"lobby_update\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n\n            case \"keep_alive\":\n              return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n\n            case \"game_start\":\n              return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n\n            case \"game_update\":\n              return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n\n            case \"answer_question\":\n              return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n  \n            default:\n              throw new Error(`${parsedMsg.type} is not a valid request type.`);\n          }\n  \n        case \"res\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n  \n            case \"lobby_leave\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n  \n            case \"lobby_update\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n\n            case \"keep_alive\":\n              return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n\n            case \"game_start\":\n              return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n\n            case \"game_update\":\n              return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n\n            case \"answer_question\":\n              return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n  \n            default:\n              throw new Error(`${parsedMsg.type} is not a valid response type.`);\n          }\n        \n        case \"post\":\n          switch (parsedMsg.type) {\n            case \"lobby_close\":\n              return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid post type.`);\n          }\n\n        default:\n          throw new Error(`${parsedMsg.method} is not a valid message method.`);\n      }\n    } catch (error) {\n      console.log(error);\n      console.log(parsedMsg);\n    }\n  } else {\n    return undefined;\n  }\n}\n\nexport default NakoAPI;"]},"metadata":{},"sourceType":"module"}