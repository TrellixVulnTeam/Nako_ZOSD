{"ast":null,"code":"import { delay } from \"../utils\";\n\nconst tuple = (...args) => args;\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n  subscribe(method, type, callbackFn) {\n    this.lifetimeSubscriptionCount++;\n    let resolve;\n    const promise = new Promise(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n    const sub = {\n      method: method,\n      type: type,\n      fn: callbackFn !== null && callbackFn !== void 0 ? callbackFn : () => {\n        this.unsubscribe(id);\n      },\n      res: resolve,\n      id: id\n    };\n    this.subscriptions.push(sub);\n    return callbackFn ? id : promise;\n  }\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n\n\n  unsubscribe(id) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`);\n    }\n  }\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n\n\n  unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  close(code, reason) {\n    this.connection.close(code, reason);\n  }\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n\n\n  async send(msg, timeout = -1) {\n    this.connection.send(JSON.stringify(msg));\n\n    if (msg.method === \"req\") {\n      let res;\n\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = await this.subscribe(\"res\", msg.type);\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL, websocketEvents) {\n    this.connection = void 0;\n    this.subscriptions = new Array();\n    this.lifetimeSubscriptionCount = 0;\n    this.onMessage = void 0;\n    this.onError = void 0;\n    window.Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg; // Resolve onMessage\n\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ? this.onMessage.forEach(i => i(parsedMsg)) : this.onMessage(parsedMsg);\n          } // Resolve subscriptions\n\n\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.log(\"Invalid message:\");\n          console.log(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\");\n        console.log(error);\n        console.log(e.data);\n      }\n    };\n\n    this.connection.onerror = e => {\n      var _this$onError;\n\n      return (_this$onError = this.onError) === null || _this$onError === void 0 ? void 0 : _this$onError.call(this, e);\n    };\n\n    this.onMessage = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onMessage;\n    this.onError = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onError;\n  }\n\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\nexport function parseMessage(msg) {\n  const msgObject = JSON.parse(msg); // Should still return false when undefined\n\n  if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n    // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n    const parsedMsg = msgObject;\n\n    try {\n      switch (parsedMsg.method) {\n        case \"req\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg;\n\n            case \"lobby_leave\":\n              return parsedMsg;\n\n            case \"lobby_update\":\n              return parsedMsg;\n\n            case \"keep_alive\":\n              return parsedMsg;\n\n            case \"game_start\":\n              return parsedMsg;\n\n            case \"game_update\":\n              return parsedMsg;\n\n            case \"answer_question\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid request type.`);\n          }\n\n        case \"res\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg;\n\n            case \"lobby_leave\":\n              return parsedMsg;\n\n            case \"lobby_update\":\n              return parsedMsg;\n\n            case \"keep_alive\":\n              return parsedMsg;\n\n            case \"game_start\":\n              return parsedMsg;\n\n            case \"game_update\":\n              return parsedMsg;\n\n            case \"answer_question\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid response type.`);\n          }\n\n        case \"post\":\n          switch (parsedMsg.type) {\n            case \"lobby_close\":\n              return parsedMsg;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid post type.`);\n          }\n\n        default:\n          throw new Error(`${parsedMsg.method} is not a valid message method.`);\n      }\n    } catch (error) {\n      console.log(error);\n      console.log(parsedMsg);\n    }\n  } else {\n    return undefined;\n  }\n}\nexport default NakoAPI;","map":{"version":3,"sources":["/Users/mac/Desktop/Nako/nako/src/modules/websocket-messages.ts"],"names":["delay","tuple","args","NakoAPI","subscribe","method","type","callbackFn","lifetimeSubscriptionCount","resolve","promise","Promise","res","id","sub","fn","unsubscribe","subscriptions","push","idx","findIndex","i","splice","Error","unsubscribeAll","close","code","reason","connection","send","msg","timeout","JSON","stringify","race","then","undefined","constructor","socketURL","websocketEvents","Array","onMessage","onError","window","Nako","WebSocket","onmessage","e","parse","data","WebSocketMessageMethodArray","includes","WebSocketMessageTypeArray","parsedMsg","isArray","forEach","filter","j","payload","console","log","error","onerror","parseMessage","msgObject"],"mappings":"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","sourcesContent":["import { delay } from \"../utils\";\n\ntype Narrowable = string | number | boolean | symbol | object | {} | void | null | undefined;\nconst tuple = <T extends Narrowable[]>(...args: T) => args;\n\ninterface WebSocketSubscription<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  fn: (res: WebSocketMessagePayload<M, T>, id: number) => void;\n  res: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n  id: number;\n}\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  private connection: WebSocket;\n\n  private subscriptions = new Array<WebSocketSubscription<WebSocketMessageMethod, WebSocketMessageType>>();\n\n  private lifetimeSubscriptionCount = 0;\n\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(method: M, type: T): Promise<WebSocketMessagePayload<M, T>>;\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn: (message: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number;\n\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn?: (payload: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number | Promise<WebSocketMessagePayload<M, T>> {\n    this.lifetimeSubscriptionCount++;\n    let resolve: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n    const promise = new Promise<WebSocketMessagePayload<M, T>>(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n\n    const sub: WebSocketSubscription<M, T> = {\n      method: method,\n      type: type,\n      fn: callbackFn ?? (() => {this.unsubscribe(id)}),\n      res: resolve!,\n      id: id\n    }\n    \n    this.subscriptions.push(sub);\n\n    return callbackFn ? id : promise;\n  }\n\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n  public unsubscribe(id: number) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`)\n    }\n  }\n\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n  public unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  public onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void | ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[];\n\n  public onError?: (e: Event) => void;\n\n  public close(code?: number, reason?: string) {\n    this.connection.close(code, reason);\n  }\n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n  public async send<M extends Exclude<WebSocketMessageMethod, \"req\">, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>): Promise<void>;\n  \n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @param  timeout This is the duration in ms that this function will wait for a response. Default is -1.\n   *                 Any value below 0 represents no timeout limit. No effects on response messages.\n   * @returns        A promise that is resolved to either a WebSocketMessagePayload when a response is received, or undefined if no response is received before timeout.\n   */\n  public async send<M extends \"req\", T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout?: number): Promise<undefined | WebSocketMessagePayload<\"res\", T>>;\n\n  public async send<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout = -1): Promise<void | undefined | WebSocketMessagePayload<\"res\", T>> {\n    this.connection.send(JSON.stringify(msg));\n\n    if (msg.method === \"req\") {\n      let res: undefined | WebSocketMessagePayload<\"res\", T>;\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = (await this.subscribe(\"res\", msg.type)) as WebSocketMessagePayload<\"res\", T>;\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL: string, websocketEvents?: {\n    onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void,\n    onError?: (e: Event) => void\n  }) {\n    (window as any).Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n          \n          // Resolve onMessage\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ?\n            (this.onMessage as ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[]).forEach(i => i(parsedMsg)) :\n            this.onMessage(parsedMsg);\n          }\n          \n          // Resolve subscriptions\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.log(\"Invalid message:\");\n          console.log(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\")\n        console.log(error);\n        console.log(e.data);\n      }\n    }\n\n    this.connection.onerror = e => this.onError?.(e);\n\n    this.onMessage = websocketEvents?.onMessage;\n    this.onError = websocketEvents?.onError;\n  }\n}\n\nexport interface LobbyInfo {\n  id: number;\n  players: string[];    // Should include self\n}\n\nexport interface QuestionInfo {\n  question: string;\n  choices: string[];\n  timeLimit: number;\n}\n\nexport interface GameInfo {\n  questions: QuestionInfo[]\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\n\nexport type WebSocketMessageMethod = (typeof WebSocketMessageMethodArray)[number];\n\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\n\nexport type WebSocketMessageType = (typeof WebSocketMessageTypeArray)[number];\n\nexport type WebSocketMessagePayload<M extends WebSocketMessageMethod, T extends WebSocketMessageType> =\n  M extends \"req\" ? \n    T extends \"lobby_join\" ? LobbyJoinRequest :\n    T extends \"lobby_leave\" ? LobbyLeaveRequest :\n    T extends \"lobby_update\" ? LobbyUpdateRequest :\n    T extends \"keep_alive\" ? KeepAliveRequest :\n    T extends \"game_start\" ? GameStartRequest :\n    T extends \"game_update\" ? GameUpdateRequest :\n    T extends \"question_start\" ? QuestionStartRequest :\n    T extends \"question_end\" ? QuestionEndRequest :\n    T extends \"answer_question\" ? AnswerQuestionRequest :\n    T extends \"lobby_close\" ? never :\n    WebSocketRequest :\n  M extends \"res\" ?\n    T extends \"lobby_join\" ? LobbyJoinResponse :\n    T extends \"lobby_leave\" ? LobbyLeaveResponse :\n    T extends \"lobby_update\" ? LobbyUpdateResponse :\n    T extends \"keep_alive\" ? KeepAliveResponse :\n    T extends \"game_start\" ? GameStartResponse :\n    T extends \"game_update\" ? GameUpdateResponse :\n    T extends \"question_start\" ? QuestionStartResponse :\n    T extends \"question_end\" ? QuestionEndResponse :\n    T extends \"answer_question\" ? AnswerQuestionResponse :\n    T extends \"lobby_close\" ? never :\n    WebSocketResponse :\n  M extends \"post\" ?\n    T extends \"lobby_close\" ? LobbyCloseEvent :\n    T extends \"lobby_join\" ? never :\n    T extends \"lobby_leave\" ? never :\n    T extends \"lobby_update\" ? never :\n    T extends \"keep_alive\" ? never :\n    T extends \"game_start\" ? never :\n    T extends \"game_update\" ? never :\n    T extends \"question_start\" ? never :\n    T extends \"question_end\" ? never :\n    T extends \"answer_question\" ? never :\n    WebSocketPost :\n  WebSocketRequest | WebSocketResponse\n\nexport interface WebSocketMessageMetadata<M extends WebSocketMessageMethod, T extends WebSocketMessageType> {\n  method: M;\n  type: T;\n}\n\nexport interface WebSocketMessage<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  payload: WebSocketMessagePayload<M, T>;\n}\n\nexport type WebSocketRequest = LobbyJoinRequest | LobbyLeaveRequest | LobbyUpdateRequest | KeepAliveRequest;\n\nexport type WebSocketResponse = LobbyJoinResponse | LobbyLeaveResponse | LobbyUpdateResponse | KeepAliveResponse;\n\nexport type WebSocketPost = LobbyCloseEvent;\n\nexport type LobbyUpdateRequest = {    // Used only to check if the lobby exists\n  lobbyID: number;\n};\n\nexport type LobbyUpdateResponse = {\n  lobbyInfo: LobbyInfo;\n};\n\nexport type LobbyJoinRequest = {\n  lobbyID: number;\n  name: string;\n};\n\nexport type LobbyJoinResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type LobbyLeaveRequest = {\n  lobbyID: number;\n  name: string;\n};\n\nexport type LobbyLeaveResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type KeepAliveRequest = null;\n\nexport type KeepAliveResponse = {\n  name: string;\n  lobbyID: number;\n};\n\nexport type GameStartRequest = {\n  gameInfo: GameInfo;\n};\n\nexport type GameStartResponse = null;\n\nexport type GameUpdateRequest = {\n  currentQuestion: number;\n};\n\nexport type GameUpdateResponse = null;\n\nexport type QuestionStartRequest = null;\n\nexport type QuestionStartResponse = null;\n\nexport type QuestionEndRequest = {\n  correctAnswer: number;\n};\n\nexport type QuestionEndResponse = null;\n\nexport type AnswerQuestionRequest = {\n  choice: number;\n};\n\nexport type AnswerQuestionResponse = null;\n\nexport type LobbyCloseEvent = {\n  reason?: string;\n};\n\nexport function parseMessage(msg: string) {\n  const msgObject = JSON.parse(msg);\n  // Should still return false when undefined\n  if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n    // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n    const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n\n    try {\n      switch (parsedMsg.method) {\n        case \"req\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n              \n            case \"lobby_leave\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n                \n            case \"lobby_update\":\n              return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n\n            case \"keep_alive\":\n              return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n\n            case \"game_start\":\n              return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n\n            case \"game_update\":\n              return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n\n            case \"answer_question\":\n              return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n  \n            default:\n              throw new Error(`${parsedMsg.type} is not a valid request type.`);\n          }\n  \n        case \"res\":\n          switch (parsedMsg.type) {\n            case \"lobby_join\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n  \n            case \"lobby_leave\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n  \n            case \"lobby_update\":\n              return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n\n            case \"keep_alive\":\n              return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n\n            case \"game_start\":\n              return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n\n            case \"game_update\":\n              return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n\n            case \"answer_question\":\n              return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n  \n            default:\n              throw new Error(`${parsedMsg.type} is not a valid response type.`);\n          }\n        \n        case \"post\":\n          switch (parsedMsg.type) {\n            case \"lobby_close\":\n              return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n\n            default:\n              throw new Error(`${parsedMsg.type} is not a valid post type.`);\n          }\n\n        default:\n          throw new Error(`${parsedMsg.method} is not a valid message method.`);\n      }\n    } catch (error) {\n      console.log(error);\n      console.log(parsedMsg);\n    }\n  } else {\n    return undefined;\n  }\n}\n\nexport default NakoAPI;"]},"metadata":{},"sourceType":"module"}