{"ast":null,"code":"import { delay } from \"../utils\";\n\nconst tuple = (...args) => args;\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n  subscribe(method, type, callbackFn) {\n    this.lifetimeSubscriptionCount++;\n    let resolve;\n    const promise = new Promise(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n    const sub = {\n      method: method,\n      type: type,\n      fn: callbackFn !== null && callbackFn !== void 0 ? callbackFn : () => {\n        this.unsubscribe(id);\n      },\n      res: resolve,\n      id: id\n    };\n    this.subscriptions.push(sub);\n    return callbackFn ? id : promise;\n  }\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n\n\n  unsubscribe(id) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`);\n    }\n  }\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n\n\n  unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  close(code, reason) {\n    this.connection.close(code, reason);\n  }\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n\n\n  async send(msg, timeout = -1) {\n    this.connection.send(JSON.stringify(msg));\n\n    if (msg.method === \"req\") {\n      let res;\n\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = await this.subscribe(\"res\", msg.type);\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL, websocketEvents) {\n    this.connection = void 0;\n    this.subscriptions = new Array();\n    this.lifetimeSubscriptionCount = 0;\n    this.onMessage = void 0;\n    this.onClose = void 0;\n    this.onError = void 0;\n    window.Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg; // Resolve onMessage\n\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ? this.onMessage.forEach(i => i(parsedMsg)) : this.onMessage(parsedMsg);\n          } // Resolve subscriptions\n\n\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.warn(\"Invalid message:\");\n          console.warn(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\");\n        console.error(error);\n        console.error(e.data);\n      }\n    };\n\n    this.connection.onclose = e => {\n      var _this$onClose;\n\n      return (_this$onClose = this.onClose) === null || _this$onClose === void 0 ? void 0 : _this$onClose.call(this, e);\n    };\n\n    this.connection.onerror = e => {\n      var _this$onError;\n\n      return (_this$onError = this.onError) === null || _this$onError === void 0 ? void 0 : _this$onError.call(this, e);\n    };\n\n    this.onMessage = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onMessage;\n    this.onClose = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onClose;\n    this.onError = websocketEvents === null || websocketEvents === void 0 ? void 0 : websocketEvents.onError;\n  }\n\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"game_end\", \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\n// export function parseMessage(msg: string) {\n//   const msgObject = JSON.parse(msg);\n//   // Should still return false when undefined\n//   if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n//     // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n//     const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n//     try {\n//       switch (parsedMsg.method) {\n//         case \"req\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid request type.`);\n//           }\n//         case \"res\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid response type.`);\n//           }\n//         case \"post\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_close\":\n//               return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid post type.`);\n//           }\n//         default:\n//           throw new Error(`${parsedMsg.method} is not a valid message method.`);\n//       }\n//     } catch (error) {\n//       console.log(error);\n//       console.log(parsedMsg);\n//     }\n//   } else {\n//     return undefined;\n//   }\n// }\nexport default NakoAPI;","map":{"version":3,"sources":["/Users/mac/Desktop/Nako/nako/src/modules/websocket-messages.ts"],"names":["delay","tuple","args","NakoAPI","subscribe","method","type","callbackFn","lifetimeSubscriptionCount","resolve","promise","Promise","res","id","sub","fn","unsubscribe","subscriptions","push","idx","findIndex","i","splice","Error","unsubscribeAll","close","code","reason","connection","send","msg","timeout","JSON","stringify","race","then","undefined","constructor","socketURL","websocketEvents","Array","onMessage","onClose","onError","window","Nako","WebSocket","onmessage","e","parse","data","WebSocketMessageMethodArray","includes","WebSocketMessageTypeArray","parsedMsg","isArray","forEach","filter","j","payload","console","warn","error","log","onclose","onerror"],"mappings":"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","sourcesContent":["import { delay } from \"../utils\";\n\ntype Narrowable = string | number | boolean | symbol | object | {} | void | null | undefined;\nconst tuple = <T extends Narrowable[]>(...args: T) => args;\n\ninterface WebSocketSubscription<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  fn: (res: WebSocketMessagePayload<M, T>, id: number) => void;\n  res: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n  id: number;\n}\n\n/**`\n * @class A class to send and receive Nako WebSocket messages.\n */\nclass NakoAPI {\n  private connection: WebSocket;\n\n  private subscriptions = new Array<WebSocketSubscription<WebSocketMessageMethod, WebSocketMessageType>>();\n\n  private lifetimeSubscriptionCount = 0;\n\n  /**\n   * Returns a Promise that resolves to the first matching message. The subscription is cancelled after the promise is returned.\n   * @param method The method of the message.\n   * @param type   The type of the message.\n   * @returns      A Promise that resolves to the first matching message.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(method: M, type: T): Promise<WebSocketMessagePayload<M, T>>;\n\n  /**\n   * Triggers the callback function when a message of matching method and type is received.\n   * @param method     The method of the message.\n   * @param type       The type of the message.\n   * @param callbackFn The callback function that will be called when a matching message is received.\n   * @returns          The ID of the subscription.\n   */\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn: (message: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number;\n\n  // I hope I find a way such that it is possible to do .subscribe<M, T>(...).reply(msg) like a Promise.\n\n  public subscribe<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(\n    method: M, type: T, callbackFn?: (payload: WebSocketMessagePayload<M, T>, id: number) => void\n  ): number | Promise<WebSocketMessagePayload<M, T>> {\n    this.lifetimeSubscriptionCount++;\n    let resolve: (value: WebSocketMessagePayload<M, T> | PromiseLike<WebSocketMessagePayload<M, T>>) => void;\n    const promise = new Promise<WebSocketMessagePayload<M, T>>(res => resolve = res);\n    const id = this.lifetimeSubscriptionCount;\n\n    const sub: WebSocketSubscription<M, T> = {\n      method: method,\n      type: type,\n      fn: callbackFn ?? (() => {this.unsubscribe(id)}),\n      res: resolve!,\n      id: id\n    }\n    \n    this.subscriptions.push(sub);\n\n    return callbackFn ? id : promise;\n  }\n\n  /**\n   * Unsubscribes a subscription by ID.\n   * @param id The ID of the subscription.\n   */\n  public unsubscribe(id: number) {\n    const idx = this.subscriptions.findIndex(i => i.id === id);\n\n    if (idx !== -1) {\n      this.subscriptions.splice(idx, 1);\n    } else {\n      throw new Error(`Subscription with ID ${id} not found.`)\n    }\n  }\n\n  /**\n   * Unsubscribes all active subscriptions.\n   */\n  public unsubscribeAll() {\n    this.subscriptions = [];\n  }\n\n  public onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void | ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[];\n\n  public onClose?: (e: CloseEvent) => void;\n\n  public onError?: (e: Event) => void;\n\n  public close(code?: number, reason?: string) {\n    this.connection.close(code, reason);\n  }\n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg The message to send.\n   */\n  public async send<M extends Exclude<WebSocketMessageMethod, \"req\">, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>): Promise<void>;\n  \n\n  /**\n   * Sends a message through the WebSocket connection.\n   * @param  msg     The message to send.\n   * @param  timeout This is the duration in ms that this function will wait for a response. Default is -1.\n   *                 Any value below 0 represents no timeout limit. No effects on response messages.\n   * @returns        A promise that is resolved to either a WebSocketMessagePayload when a response is received, or undefined if no response is received before timeout.\n   */\n  public async send<M extends \"req\", T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout?: number): Promise<undefined | WebSocketMessagePayload<\"res\", T>>;\n\n  public async send<M extends WebSocketMessageMethod, T extends WebSocketMessageType>(msg: WebSocketMessage<M, T>, timeout = -1): Promise<void | undefined | WebSocketMessagePayload<\"res\", T>> {\n    this.connection.send(JSON.stringify(msg));\n\n    if (msg.method === \"req\") {\n      let res: undefined | WebSocketMessagePayload<\"res\", T>;\n      if (timeout >= 0) {\n        res = await Promise.race([this.subscribe(\"res\", msg.type), delay(timeout).then(() => undefined)]);\n      } else {\n        res = (await this.subscribe(\"res\", msg.type)) as WebSocketMessagePayload<\"res\", T>;\n      }\n\n      return res;\n    }\n  }\n\n  constructor(socketURL: string, websocketEvents?: {\n    onMessage?: (data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void,\n    onClose?: (e: CloseEvent) => void,\n    onError?: (e: Event) => void\n  }) {\n    (window as any).Nako = this;\n    this.connection = new WebSocket(socketURL);\n\n    this.connection.onmessage = e => {\n      try {\n        const msg = JSON.parse(e.data);\n\n        if (WebSocketMessageMethodArray.includes(msg.method) && WebSocketMessageTypeArray.includes(msg.type)) {\n          const parsedMsg = msg as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n          \n          // Resolve onMessage\n          if (this.onMessage) {\n            Array.isArray(this.onMessage) ?\n            (this.onMessage as ((data: WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>) => void)[]).forEach(i => i(parsedMsg)) :\n            this.onMessage(parsedMsg);\n          }\n          \n          // Resolve subscriptions\n          for (const i of this.subscriptions.filter(j => j.method === parsedMsg.method && j.type === parsedMsg.type)) {\n            i.res(parsedMsg.payload);\n            i.fn(parsedMsg.payload, i.id);\n          }\n        } else {\n          console.warn(\"Invalid message:\");\n          console.warn(msg);\n        }\n      } catch (error) {\n        console.log(\"An error occurred while processing the message:\")\n        console.error(error);\n        console.error(e.data);\n      }\n    }\n\n    this.connection.onclose = e => this.onClose?.(e);\n    this.connection.onerror = e => this.onError?.(e);\n    this.onMessage = websocketEvents?.onMessage;\n    this.onClose = websocketEvents?.onClose;\n    this.onError = websocketEvents?.onError;\n  }\n}\n\nexport interface LobbyInfo {\n  id: number;\n  players: string[];    // Should include self\n}\n\nexport interface QuestionInfo {\n  question: string;\n  choices: string[];\n  timeLimit: number;\n}\n\nexport interface GameInfo {\n  questions: QuestionInfo[]\n}\n\nconst WebSocketMessageMethodArray = tuple(\"req\", \"res\", \"post\");\n\nexport type WebSocketMessageMethod = (typeof WebSocketMessageMethodArray)[number];\n\nconst WebSocketMessageTypeArray = tuple(\"lobby_join\", \"lobby_leave\", \"lobby_update\", \"keep_alive\", \"game_start\", \"game_update\", \"game_end\",\n                                        \"question_start\", \"question_end\", \"answer_question\", \"lobby_close\");\n\nexport type WebSocketMessageType = (typeof WebSocketMessageTypeArray)[number];\n\nexport type WebSocketMessagePayload<M extends WebSocketMessageMethod, T extends WebSocketMessageType> =\n  M extends \"req\" ? \n    T extends \"lobby_join\" ? LobbyJoinRequest :\n    T extends \"lobby_leave\" ? LobbyLeaveRequest :\n    T extends \"lobby_update\" ? LobbyUpdateRequest :\n    T extends \"keep_alive\" ? KeepAliveRequest :\n    T extends \"game_start\" ? GameStartRequest :\n    T extends \"game_update\" ? GameUpdateRequest :\n    T extends \"game_end\" ? GameEndRequest :\n    T extends \"question_start\" ? QuestionStartRequest :\n    T extends \"question_end\" ? QuestionEndRequest :\n    T extends \"answer_question\" ? AnswerQuestionRequest :\n    T extends \"lobby_close\" ? never :\n    WebSocketRequest :\n  M extends \"res\" ?\n    T extends \"lobby_join\" ? LobbyJoinResponse :\n    T extends \"lobby_leave\" ? LobbyLeaveResponse :\n    T extends \"lobby_update\" ? LobbyUpdateResponse :\n    T extends \"keep_alive\" ? KeepAliveResponse :\n    T extends \"game_start\" ? GameStartResponse :\n    T extends \"game_update\" ? GameUpdateResponse :\n    T extends \"game_end\" ? GameEndResponse :\n    T extends \"question_start\" ? QuestionStartResponse :\n    T extends \"question_end\" ? QuestionEndResponse :\n    T extends \"answer_question\" ? AnswerQuestionResponse :\n    T extends \"lobby_close\" ? never :\n    WebSocketResponse :\n  M extends \"post\" ?\n    T extends \"lobby_close\" ? LobbyCloseEvent :\n    T extends \"lobby_join\" ? never :\n    T extends \"lobby_leave\" ? never :\n    T extends \"lobby_update\" ? never :\n    T extends \"keep_alive\" ? never :\n    T extends \"game_start\" ? never :\n    T extends \"game_update\" ? never :\n    T extends \"game_end\" ? never :\n    T extends \"question_start\" ? never :\n    T extends \"question_end\" ? never :\n    T extends \"answer_question\" ? never :\n    WebSocketPost :\n  WebSocketRequest | WebSocketResponse\n\nexport interface WebSocketMessageMetadata<M extends WebSocketMessageMethod, T extends WebSocketMessageType> {\n  method: M;\n  type: T;\n}\n\nexport interface WebSocketMessage<M extends WebSocketMessageMethod, T extends WebSocketMessageType> extends WebSocketMessageMetadata<M, T> {\n  payload: WebSocketMessagePayload<M, T>;\n}\n\nexport type WebSocketRequest = LobbyJoinRequest | LobbyLeaveRequest | LobbyUpdateRequest | KeepAliveRequest;\n\nexport type WebSocketResponse = LobbyJoinResponse | LobbyLeaveResponse | LobbyUpdateResponse | KeepAliveResponse;\n\nexport type WebSocketPost = LobbyCloseEvent;\n\nexport type LobbyUpdateRequest = {    // Used only to check if the lobby exists\n  lobbyID: number;\n};\n\nexport type LobbyUpdateResponse = {\n  lobbyInfo: LobbyInfo;\n};\n\nexport type LobbyJoinRequest = {\n  lobbyID: number;\n  name: string;\n};\n\nexport type LobbyJoinResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type LobbyLeaveRequest = {\n  lobbyID: number;\n  name: string;\n};\n\nexport type LobbyLeaveResponse = {\n  lobbyInfo: LobbyInfo | null;\n  error?: string;\n};\n\nexport type KeepAliveRequest = null;\n\nexport type KeepAliveResponse = {\n  name: string;\n  lobbyID: number;\n};\n\nexport type GameStartRequest = {\n  gameInfo: GameInfo;\n};\n\nexport type GameStartResponse = null;\n\nexport type GameUpdateRequest = {\n  currentQuestion: number;\n};\n\nexport type GameUpdateResponse = null;\n\nexport type GameEndRequest = {\n  result: {\n    name: string;\n    score: number;\n  }[]\n}\n\nexport type GameEndResponse = null;\n\nexport type QuestionStartRequest = null;\n\nexport type QuestionStartResponse = null;\n\nexport type QuestionEndRequest = {\n  correctAnswer: number;\n};\n\nexport type QuestionEndResponse = null;\n\nexport type AnswerQuestionRequest = {\n  choice: number;\n};\n\nexport type AnswerQuestionResponse = null;\n\nexport type LobbyCloseEvent = {\n  reason?: string;\n};\n\n// export function parseMessage(msg: string) {\n//   const msgObject = JSON.parse(msg);\n//   // Should still return false when undefined\n//   if (WebSocketMessageMethodArray.includes(msgObject.method) && WebSocketMessageTypeArray.includes(msgObject.type)) {\n//     // Since JavaScript is still intrinsically loose typed, this is the shit that we have to do\n//     const parsedMsg = msgObject as WebSocketMessage<WebSocketMessageMethod, WebSocketMessageType>;\n\n//     try {\n//       switch (parsedMsg.method) {\n//         case \"req\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_join\">;\n              \n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_leave\">;\n                \n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"lobby_update\">;\n\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"keep_alive\">;\n\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_start\">;\n\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"game_update\">;\n\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"req\", \"answer_question\">;\n  \n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid request type.`);\n//           }\n  \n//         case \"res\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_join\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_join\">;\n  \n//             case \"lobby_leave\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_leave\">;\n  \n//             case \"lobby_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"lobby_update\">;\n\n//             case \"keep_alive\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"keep_alive\">;\n\n//             case \"game_start\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_start\">;\n\n//             case \"game_update\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"game_update\">;\n\n//             case \"answer_question\":\n//               return parsedMsg as WebSocketMessage<\"res\", \"answer_question\">;\n  \n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid response type.`);\n//           }\n        \n//         case \"post\":\n//           switch (parsedMsg.type) {\n//             case \"lobby_close\":\n//               return parsedMsg as WebSocketMessage<\"post\", \"lobby_close\">;\n\n//             default:\n//               throw new Error(`${parsedMsg.type} is not a valid post type.`);\n//           }\n\n//         default:\n//           throw new Error(`${parsedMsg.method} is not a valid message method.`);\n//       }\n//     } catch (error) {\n//       console.log(error);\n//       console.log(parsedMsg);\n//     }\n//   } else {\n//     return undefined;\n//   }\n// }\n\nexport default NakoAPI;"]},"metadata":{},"sourceType":"module"}